#include <iostream>
#include <string>
#include <stdlib.h>

using namespace std;
//базовый(родительский) класс
class Animal
{
protected:
    string Title; //кличка животного
public:
    //Конструктор с параметром
    Animal(string T) :Title{ T } {}
    //вирутальный метод, который может быть перегружен в дочерних классах
    virtual void Speak()
    {
        cout << "Издает Звук!" << endl;
    }

    //virtual void Speak() = 0; //чисто-виртуальный метод обязательно должен быть реализован
    //во всех дочерних классах, наследниках класса Animal
    //чисто-вирутальный метод превращает класс в абстрактный, запрещает создавать объекты такого классы

    //virtual ~Animal() = default; //виртуальный деструктор, при уничтожении объектов дочерних классов,
    //virtual ~Animal() {}; //через указатель на родительский класс, будут вызываться деструкторы дочерних классов, а не родительский

    virtual ~Animal() = 0; //чисто-виртуальный деструктор превращает класс в абстрактный
};
//Если будет наследовать класс Animal, то нужно добвать реализацию деструктора, хотя бы пустую
//Animal::~Animal() = default; //реализация должна быть глобальной
Animal::~Animal() //реализация должна быть глобальной
{
    //здесь может быть код, выполняемый при уничтожении "рожительского содержимого", находящегося внутри 
    //объектов дочерних классов, при их уничтожении
}

//дочерние классы
//класс собака
class Dog : virtual public Animal //virtual указанный при наследовании помогает избежать дублирования содержимого
{//родительского класса в наследниках класса Dog и "отключает" автоматический вызов конструктора класса Animal в дочерних калсса класса Dog
    //Title - унаследовано от родителя
public:
    //конструктор дочернего класса Dog явно вызывает конструктор родительского класса Animal
    Dog(string T) : Animal(T) {};
    //перегрузка родительского метода
    void Speak() override //проверка соответсвия заголовка метода в дочернем и в продительском классах
    {
        cout << Title << R"( говорит: "Гав-Гав!")" << endl;
    }
};
//класс кошка
class Cat : virtual public Animal //virtual указанный при наследовании помогает избежать дублирования содержимого
{//родительского класса в наследниках класса Cat и "отключает" автоматический вызов конструктора класса Animal в дочерних калсса класса Cat
     //Title - унаследовано от родителя
public:
    //конструктор дочернего класса Cat явно вызывает конструктор родительского класса Animal
    Cat(string T) :Animal(T) {};
    //перегрузка родительского метода
    void Speak() override
    {
        cout << Title << R"( говорит: "Мяу-Мяу!")" << endl;
    }
};
//класс лягушка
class Frog : public Animal
{
    //Title - унаследовано от родителя
public:
    //конструктор дочернего класса Frog явно вызывает конструктор родительского класса Animal
    Frog(string T) :Animal(T) {};
    //перегрузка родительского метода
    void Speak()
    {
        cout << Title << R"( говорит: "Ква-Ква!")" << endl;
    }
};
//класс лев
class Lion : public Cat
{

    //Title - унаследовано от родителя
public:
    //конструктор дочернего класса Lion явно вызывает конструктор родительского класса Cat
    Lion(string T) :Cat(T), Animal(T) {} //и конструктор класса Animal
    //перегрузка родительского метода
    void Speak()
    {
        cout << Title << R"( говорит: "Ррр-Ррр!")" << endl;
    }
    //собственный метод класса Lion, может быть унаследован дочерними классами класса Lion
    void Speak(int)
    {
        cout << Title << R"( говорит: "Аум-Аум!")" << endl;
    }
};
//класс тигр
class Tiger : public Cat
{
    //Title - унаследовано от родителя
public:
    //конструктор дочернего класса Tiger явно вызывает конструктор родительского класса Cat
    Tiger(string T) :Cat(T), Animal(T) {} //и конструктор класса Animal
    //перегрузка родительского метода
    void Speak()
    {
        cout << Title << R"( говорит: "Грр-Грр!")" << endl;
    }

};
//класс котопес
class CatDog : public Cat, public Dog
{
public:
    //конструктор для ДЗ
    //CatDog(string T) : Cat(T), Dog(T), Animal(T) {}
    CatDog(string TCat, string TDog) :Cat(TCat), Dog(TDog), Animal(TCat + "о" + TDog) {}
    //конструктор дочернего класса явно вызывает конструкторы обоих родительских классов
    //и явно вызывает конструктор класса Animal
    virtual void Speak() override
    {
        cout << Title << R"( говорит: "Мяу-Гав!")" << endl;
    }
};
//класс лигр
class Ligr : public Lion, public Tiger
{
public:
    //конструктор для ДЗ
    //CatDog(string T) : Cat(T), Dog(T), Animal(T) {}
    Ligr(string T) :Lion(T), Tiger(T), Animal(T) {}
    //конструктор дочернего класса явно вызывает конструкторы обоих родительских классов
    //и явно вызывает конструктор класса Animal
    virtual void Speak() override
    {
        cout << Title << R"( говорит: "Грр-Аум!")" << endl;
    }
};

int main()
{
    system("chcp 1251 > NUL"); //смена кодовой страницы без вывода фразы на экран
    const int Size = 7;
    //статический массив указателей на родительский класса Animal, хранящий адреса объектов дочерних классов
    Animal* ZOO[Size] =
    {
        new Dog("Бобик"),
        new Cat("Пушок"),
        new Frog("Квакушка"),
        new Lion("Симба"),
        new CatDog("Кот","Пес"),
        new Tiger("Шерхан"),
        new Ligr("Геркулес")
    };
    //ZOO[3]->Speak();      //вызов реализации из дочернего класа виртуального метода родительского класса
    //ZOO[3]->Speak(10);    //через указатель на родительский класс Animal*
    //мы можем вызвать реализацию только виртуального метода родительского класса изи дочернего класса
    //Lion Lev("Муфаса");
    //Lev.Speak(); //вызов реализации родительского метода
    //Lev.Speak(10); //вызов реализации собственного метода   

    int index = 0; //номер "кнопки"

    do
    {
        system("cls");
        cout << R"(Выберите животное:
1. "Бобик"
2. "Пушок"
3. "Квакушка"
4. "Симба"
5. "КотоПес"
6."Шерхан"
7."Геркулес"
0. Выход
)";
        do
        {
            cin >> index;
            if (index<0 || index>Size)cout << "Некорреткный ввод! Попробуйте ещё раз!" << endl;
        } while (index<0 || index>Size);
        if (index == 0)break; //выход из программы
        ZOO[index - 1]->Speak(); //метод Speak вызывается из того класса,  через адрес объекта которого мы его вызываем
        system("pause");
    } while (index != 0);

    //освобождение памяти
    for (int i = 0; i < Size; i++)
    {
        delete ZOO[i];      //вызывается родительский деструктор ~Animal()
        ZOO[i] = nullptr;
    }

    //Animal Beast("Зверь"); //объект родительского класса
    //Beast.Speak();

}